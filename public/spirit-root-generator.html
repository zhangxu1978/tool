<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¿®ä»™çµæ ¹ç”Ÿæˆå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .spirit-root-display {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .element-card {
            background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .element-card:hover {
            transform: translateY(-5px);
        }

        .element-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .element-state {
            font-size: 1.5em;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .state-yang { background-color: #ff6b6b; color: white; }
        .state-yin { background-color: #4ecdc4; color: white; }
        .state-none { background-color: #95a5a6; color: white; }
        .state-waste { background-color: #e74c3c; color: white; text-decoration: line-through; }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .btn-primary {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(145deg, #56ab2f, #a8e6cf);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(145deg, #ff416c, #ff4b2b);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .batch-test {
            margin-bottom: 30px;
            text-align: center;
        }

        .batch-test input {
            padding: 10px;
            font-size: 1em;
            border: 2px solid #ddd;
            border-radius: 5px;
            width: 150px;
            margin-right: 10px;
        }

        .statistics {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .statistics h3 {
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }

        .combination-list {
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .combination-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        .combination-item:last-child {
            border-bottom: none;
        }

        .combination-pattern {
            font-family: monospace;
            font-weight: bold;
        }

        .combination-count {
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒŸ ä¿®ä»™çµæ ¹ç”Ÿæˆå™¨ ğŸŒŸ</h1>
        
        <div class="spirit-root-display" id="spiritRootDisplay">
            <!-- çµæ ¹æ˜¾ç¤ºåŒºåŸŸ -->
        </div>

        <div class="controls">
            <button class="btn-primary" onclick="generateSpiritRoot()">ğŸ² ç”Ÿæˆçµæ ¹</button>
            <button class="btn-secondary" onclick="generateBatch()">âš¡ æ‰¹é‡ç”Ÿæˆ</button>
            <button class="btn-danger" onclick="clearStatistics()">ğŸ—‘ï¸ æ¸…ç©ºç»Ÿè®¡</button>
            <button class="btn-primary" onclick="exportResults()">ğŸ“Š å¯¼å‡ºç»“æœ</button>
        </div>

        <div class="batch-test">
            <label>æ‰¹é‡æµ‹è¯•æ¬¡æ•°ï¼š</label>
            <input type="number" id="batchCount" value="1000" min="1" max="100000">
            <button class="btn-secondary" onclick="startBatchTest()">å¼€å§‹æ‰¹é‡æµ‹è¯•</button>
        </div>

        <div class="progress-bar" id="progressBar" style="display: none;">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="statistics">
            <h3>ğŸ“ˆ ç»Ÿè®¡ä¿¡æ¯</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">æ€»ç”Ÿæˆæ¬¡æ•°</div>
                    <div class="stat-value" id="totalCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">å˜å¼‚æ¬¡æ•°</div>
                    <div class="stat-value" id="mutationCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">åºŸçµæ ¹æ¬¡æ•°</div>
                    <div class="stat-value" id="wasteCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">å˜å¼‚ç‡</div>
                    <div class="stat-value" id="mutationRate">0%</div>
                </div>
            </div>

            <div class="combination-list" id="combinationList">
                <h4>ç»„åˆç»Ÿè®¡ (å‰20ç§æœ€å¸¸è§)</h4>
                <div id="combinationStats">
                    <!-- ç»„åˆç»Ÿè®¡æ˜¾ç¤º -->
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * çµæ ¹ç”Ÿæˆå™¨ç±»
         * è´Ÿè´£ç”Ÿæˆäº”è¡Œçµæ ¹å¹¶å¤„ç†ç›¸ç”Ÿç›¸å…‹å…³ç³»
         */
        class SpiritRootGenerator {
            constructor() {
                this.elements = ['é‡‘', 'æœ¨', 'æ°´', 'ç«', 'åœŸ'];
                this.states = ['é˜³', 'é˜´', 'æ— '];
                this.wasteState = 'åºŸ';
                
                // äº”è¡Œç›¸ç”Ÿå…³ç³»ï¼šé‡‘->æ°´->æœ¨->ç«->åœŸ->é‡‘
                this.generatingCycle = {
                    'é‡‘': 'æ°´',
                    'æ°´': 'æœ¨', 
                    'æœ¨': 'ç«',
                    'ç«': 'åœŸ',
                    'åœŸ': 'é‡‘'
                };
                
                // äº”è¡Œç›¸å…‹å…³ç³»ï¼šé‡‘->æœ¨->åœŸ->æ°´->ç«->é‡‘
                this.controllingCycle = {
                    'é‡‘': 'æœ¨',
                    'æœ¨': 'åœŸ',
                    'åœŸ': 'æ°´',
                    'æ°´': 'ç«',
                    'ç«': 'é‡‘'
                };
                
                this.statistics = new Map();
                this.totalGenerations = 0;
                this.mutationCount = 0;
                this.wasteCount = 0;
            }

            /**
             * ç”Ÿæˆå•ä¸ªçµæ ¹
             * @returns {Object} åŒ…å«äº”è¡ŒçŠ¶æ€å’Œç»Ÿè®¡ä¿¡æ¯çš„çµæ ¹å¯¹è±¡
             */
            generate() {
                // ç¬¬ä¸€æ­¥ï¼šéšæœºç”Ÿæˆäº”ä¸ªç»´åº¦çš„çŠ¶æ€ï¼ˆé˜´é˜³æ— ï¼‰
                let spiritRoot = {};
                this.elements.forEach(element => {
                    spiritRoot[element] = this.states[Math.floor(Math.random() * this.states.length)];
                });

                // åˆ›å»ºå‰¯æœ¬ç”¨äºåç»­å¤„ç†
                let finalRoot = { ...spiritRoot };
                let mutations = [];
                let wasteElements = [];

                // ç¬¬äºŒæ­¥ï¼šå¤„ç†ç›¸ç”Ÿå…³ç³»
                Object.entries(this.generatingCycle).forEach(([element, generatedElement]) => {
                    const elementState = spiritRoot[element];
                    const generatedState = spiritRoot[generatedElement];
                    
                    if (elementState !== 'æ— ' && generatedState !== 'æ— ') {
                        if (elementState !== generatedState) {
                            // ä¸€é˜´ä¸€é˜³ï¼Œå‘ç”Ÿå˜å¼‚
                            const isEnhancement = (elementState === 'é˜´' && generatedState === 'é˜³');
                            finalRoot[generatedElement] = isEnhancement ? 'é˜³+' : 'é˜´-';
                            mutations.push({
                                type: isEnhancement ? 'å¼ºåŒ–' : 'å¼±åŒ–',
                                from: element,
                                to: generatedElement,
                                reason: `${elementState}${element} â†’ ${generatedState}${generatedElement}`
                            });
                        }
                    }
                });

                // ç¬¬ä¸‰æ­¥ï¼šå¤„ç†ç›¸å…‹å…³ç³»
                Object.entries(this.controllingCycle).forEach(([element, controlledElement]) => {
                    const elementState = spiritRoot[element];
                    const controlledState = spiritRoot[controlledElement];
                    
                    if (elementState !== 'æ— ' && controlledState !== 'æ— ') {
                        if (elementState === controlledState) {
                            // åŒè´¨ç›¸å…‹ï¼Œè¢«å…‹å…ƒç´ å˜ä¸ºåºŸçŠ¶æ€
                            finalRoot[controlledElement] = this.wasteState;
                            wasteElements.push(controlledElement);
                        }
                    }
                });

                // ç»Ÿè®¡
                this.updateStatistics(finalRoot, mutations.length, wasteElements.length);

                return {
                    root: finalRoot,
                    original: spiritRoot,
                    mutations: mutations,
                    wasteElements: wasteElements,
                    hasMutation: mutations.length > 0,
                    hasWaste: wasteElements.length > 0
                };
            }

            /**
             * æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
             */
            updateStatistics(finalRoot, mutationCount, wasteCount) {
                this.totalGenerations++;
                this.mutationCount += mutationCount > 0 ? 1 : 0;
                this.wasteCount += wasteCount > 0 ? 1 : 0;

                // ç”Ÿæˆç»„åˆæ¨¡å¼å­—ç¬¦ä¸²
                const pattern = this.elements.map(el => finalRoot[el]).join('-');
                this.statistics.set(pattern, (this.statistics.get(pattern) || 0) + 1);
            }

            /**
             * è·å–ç»Ÿè®¡ä¿¡æ¯
             */
            getStatistics() {
                return {
                    total: this.totalGenerations,
                    mutations: this.mutationCount,
                    waste: this.wasteCount,
                    mutationRate: this.totalGenerations > 0 ? 
                        ((this.mutationCount / this.totalGenerations) * 100).toFixed(2) : 0,
                    wasteRate: this.totalGenerations > 0 ? 
                        ((this.wasteCount / this.totalGenerations) * 100).toFixed(2) : 0,
                    combinations: Array.from(this.statistics.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 20)
                };
            }

            /**
             * æ¸…ç©ºç»Ÿè®¡
             */
            clearStatistics() {
                this.statistics.clear();
                this.totalGenerations = 0;
                this.mutationCount = 0;
                this.wasteCount = 0;
            }

            /**
             * æ‰¹é‡ç”Ÿæˆ
             */
            async generateBatch(count, progressCallback) {
                const results = [];
                const batchSize = 100;
                
                for (let i = 0; i < count; i += batchSize) {
                    const currentBatch = Math.min(batchSize, count - i);
                    
                    for (let j = 0; j < currentBatch; j++) {
                        results.push(this.generate());
                    }
                    
                    if (progressCallback) {
                        progressCallback(Math.min(i + currentBatch, count), count);
                    }
                    
                    // è®©å‡ºæ§åˆ¶æƒï¼Œé¿å…ç•Œé¢å¡é¡¿
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                return results;
            }
        }

        // å…¨å±€å®ä¾‹
        const generator = new SpiritRootGenerator();

        /**
         * ç”Ÿæˆå•ä¸ªçµæ ¹å¹¶æ˜¾ç¤º
         */
        function generateSpiritRoot() {
            const result = generator.generate();
            displaySpiritRoot(result);
            updateStatisticsDisplay();
        }

        /**
         * æ˜¾ç¤ºçµæ ¹
         */
        function displaySpiritRoot(result) {
            const display = document.getElementById('spiritRootDisplay');
            display.innerHTML = '';

            generator.elements.forEach(element => {
                const state = result.root[element];
                const originalState = result.original[element];
                const card = document.createElement('div');
                card.className = 'element-card';
                
                let stateClass = '';
                let displayText = state;
                
                if (state.includes('+')) {
                    stateClass = 'state-yang';
                    displayText = 'é˜³(å¼ºåŒ–)';
                } else if (state.includes('-')) {
                    stateClass = 'state-yin';
                    displayText = 'é˜´(å¼±åŒ–)';
                } else if (state === 'é˜³') {
                    stateClass = 'state-yang';
                } else if (state === 'é˜´') {
                    stateClass = 'state-yin';
                } else if (state === 'åºŸ') {
                    stateClass = 'state-waste';
                } else {
                    stateClass = 'state-none';
                }

                card.innerHTML = `
                    <div class="element-name">${element}</div>
                    <div class="element-state ${stateClass}">${displayText}</div>
                    <div style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        åŸçŠ¶æ€: ${originalState}
                    </div>
                `;
                
                display.appendChild(card);
            });

            // æ˜¾ç¤ºå˜å¼‚ä¿¡æ¯
            if (result.hasMutation || result.hasWaste) {
                const info = document.createElement('div');
                info.style.cssText = 'grid-column: 1 / -1; background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 10px;';
                
                let infoText = '';
                if (result.hasMutation) {
                    infoText += '<strong>å˜å¼‚æƒ…å†µï¼š</strong><br>';
                    result.mutations.forEach(mutation => {
                        infoText += `â€¢ ${mutation.type}å˜å¼‚ï¼š${mutation.reason}<br>`;
                    });
                }
                if (result.hasWaste) {
                    infoText += '<strong>åºŸçµæ ¹ï¼š</strong>' + result.wasteElements.join('ã€') + '<br>';
                }
                
                info.innerHTML = infoText;
                display.appendChild(info);
            }
        }

        /**
         * æ›´æ–°ç»Ÿè®¡æ˜¾ç¤º
         */
        function updateStatisticsDisplay() {
            const stats = generator.getStatistics();
            
            document.getElementById('totalCount').textContent = stats.total;
            document.getElementById('mutationCount').textContent = stats.mutations;
            document.getElementById('wasteCount').textContent = stats.waste;
            document.getElementById('mutationRate').textContent = stats.mutationRate + '%';

            // æ›´æ–°ç»„åˆç»Ÿè®¡
            const combinationStats = document.getElementById('combinationStats');
            combinationStats.innerHTML = '';
            
            stats.combinations.forEach(([pattern, count]) => {
                const percentage = ((count / stats.total) * 100).toFixed(2);
                const item = document.createElement('div');
                item.className = 'combination-item';
                item.innerHTML = `
                    <span class="combination-pattern">${pattern}</span>
                    <span class="combination-count">${count} (${percentage}%)</span>
                `;
                combinationStats.appendChild(item);
            });
        }

        /**
         * æ‰¹é‡ç”Ÿæˆï¼ˆå¿«é€Ÿæ¨¡å¼ï¼‰
         */
        function generateBatch() {
            for (let i = 0; i < 10; i++) {
                generator.generate();
            }
            updateStatisticsDisplay();
        }

        /**
         * å¼€å§‹æ‰¹é‡æµ‹è¯•
         */
        async function startBatchTest() {
            const count = parseInt(document.getElementById('batchCount').value);
            if (count <= 0 || count > 100000) {
                alert('è¯·è¾“å…¥1-100000ä¹‹é—´çš„æ•°å­—');
                return;
            }

            // æ˜¾ç¤ºè¿›åº¦æ¡
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            progressBar.style.display = 'block';

            // ç¦ç”¨æŒ‰é’®
            const buttons = document.querySelectorAll('button');
            buttons.forEach(btn => btn.disabled = true);

            try {
                await generator.generateBatch(count, (current, total) => {
                    const progress = (current / total) * 100;
                    progressFill.style.width = progress + '%';
                });

                updateStatisticsDisplay();
                alert(`æ‰¹é‡æµ‹è¯•å®Œæˆï¼å…±ç”Ÿæˆ ${count} ä¸ªçµæ ¹`);
            } catch (error) {
                alert('æµ‹è¯•è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼š' + error.message);
            } finally {
                // éšè—è¿›åº¦æ¡å¹¶å¯ç”¨æŒ‰é’®
                progressBar.style.display = 'none';
                progressFill.style.width = '0%';
                buttons.forEach(btn => btn.disabled = false);
            }
        }

        /**
         * æ¸…ç©ºç»Ÿè®¡
         */
        function clearStatistics() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç»Ÿè®¡æ•°æ®å—ï¼Ÿ')) {
                generator.clearStatistics();
                updateStatisticsDisplay();
                document.getElementById('spiritRootDisplay').innerHTML = '';
            }
        }

        /**
         * å¯¼å‡ºç»“æœ
         */
        function exportResults() {
            const stats = generator.getStatistics();
            const timestamp = new Date().toLocaleString('zh-CN');
            
            let exportData = {
                exportTime: timestamp,
                totalGenerations: stats.total,
                mutationCount: stats.mutations,
                wasteCount: stats.waste,
                mutationRate: stats.mutationRate + '%',
                wasteRate: stats.wasteRate + '%',
                topCombinations: stats.combinations.map(([pattern, count]) => ({
                    pattern: pattern,
                    count: count,
                    percentage: ((count / stats.total) * 100).toFixed(2) + '%'
                }))
            };

            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `çµæ ¹ç”Ÿæˆç»Ÿè®¡_${new Date().getTime()}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
        }

        // é¡µé¢åŠ è½½æ—¶ç”Ÿæˆä¸€ä¸ªç¤ºä¾‹
        window.onload = function() {
            generateSpiritRoot();
        };
    </script>
</body>
</html>