<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>修仙游戏灵根生成器</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background-color: #f0f5f9;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
            font-size: 28px;
        }
        .generator-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        .panel {
            flex: 1;
            min-width: 300px;
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        .panel h2 {
            color: #495057;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 20px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        .root-display {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }
        .root-item {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            background-color: white;
            width: 80px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }
        .root-item:hover {
            transform: translateY(-3px);
        }
        .root-name {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .root-state {
            font-size: 18px;
            font-weight: bold;
        }
        .root-state.无 { color: #95a5a6; }
        .root-state.阳 { color: #f39c12; }
        .root-state.阴 { color: #3498db; }
        .root-state.废 { color: #e74c3c; }
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:active {
            transform: translateY(1px);
        }
        .analysis-panel {
            margin-top: 20px;
        }
        .analysis-item {
            margin-bottom: 10px;
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            border-left: 4px solid #007bff;
        }
        .variation {
            border-left-color: #28a745;
        }
        .weakness {
            border-left-color: #dc3545;
        }
        .summary {
            margin-top: 20px;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 5px;
        }
        .probability-section {
            margin-top: 30px;
        }
        .probability-controls {
            margin-bottom: 20px;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="number"] {
            padding: 8px;
            width: 80px;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        .probability-controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 8px;
            border: 1px solid #b3d9e6;
        }
        .probability-controls label {
            font-size: 14px;
        }
        .probability-controls input[type="number"] {
            margin-right: 5px;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            display: block;
        }
        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .results-table th {
            background-color: #007bff;
            color: white;
            position: sticky;
            top: 0;
        }
        .results-table tr:hover {
            background-color: #f5f5f5;
        }
        .export-section {
            margin-top: 20px;
            text-align: center;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 2px 5px;
            border-radius: 3px;
        }
        .algorithm-info {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 4px solid #6c757d;
        }
        .algorithm-info h3 {
            margin-top: 0;
            color: #495057;
        }
        .algorithm-info h4 {
            margin-top: 15px;
            margin-bottom: 10px;
            color: #495057;
        }
        .algorithm-info ul {
            margin-bottom: 0;
        }
        .algorithm-info li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>修仙游戏灵根生成器</h1>
        
        <div class="algorithm-info">
            <h3>灵根生成算法说明</h3>
            <ul>
                <li>金木水火土五个维度，每个维度初始有三种可能状态：<span class="highlight">无</span>、<span class="highlight">阳</span>、<span class="highlight">阴</span></li>
                <li>相生关系：如果相生位置是一阴一阳，则会发生变异（金生水，金阴水阳=强化变异，金阳水阴=弱化变异）</li>
                <li>相克关系：如果相克位置同质（双阴或双阳，但不包括双无），则变为<span class="highlight">废</span>的状态</li>
            </ul>
            
            <h4>灵根种类判断规则：</h4>
            <ul>
                <li>出现废的都是废灵根</li>
                <li>五行没有出现阳灵根的也是废灵根</li>
                <li>单灵根阳是天灵根</li>
                <li>双灵根强化变异是天灵根，无变异是地灵根、弱化变异是普通灵根</li>
                <li>三灵根强化变异的是地灵根，无变异是普通灵根，弱化变异的是杂灵根</li>
                <li>四灵根强化变异是普通灵根，没有变异的杂灵根，没有强化变异有弱化变异的是废灵根</li>
            </ul>
            
            <h4>异化灵根（1/10几率）：</h4>
            <ul>
                <li>金生水：强化变异→雷灵根，弱化变异→冰灵根</li>
                <li>水生木：强化变异→草灵根，弱化变异→毒灵根</li>
                <li>木生火：强化变异→光灵根，弱化变异→风灵根</li>
                <li>火生土：强化变异→炎灵根，弱化变异→暗灵根</li>
                <li>土生金：强化变异→磁灵根，弱化变异→岩灵根</li>
            </ul>
            
            <h4>道体（1/100几率）：</h4>
            <ul>
                <li>全阳：太初道体</li>
                <li>全阴：混沌道体</li>
                <li>全无：阴阳道体</li>
            </ul>
        </div>

        <div class="generator-panel">
            <div class="panel">
                <h2>单次灵根生成</h2>
                
                <div class="probability-controls" style="background-color: #fff8e1; border-color: #ffd54f;">
                    <h4 style="margin-top: 0; margin-bottom: 10px;">通过数据化字符串解码灵根</h4>
                    <div class="input-group">
                        <label for="dataStringInput">输入5位数字串（阳=2，阴=1，无=0）：</label>
                        <input type="text" id="dataStringInput" placeholder="例如：20211" maxlength="5">
                        <span style="margin-left: 10px; color: #666; font-size: 14px;">金木水火土顺序</span>
                    </div>
                    <button id="decodeBtn" style="background-color: #ff9800;">解码灵根</button>
                    <div id="decodeError" style="color: red; margin-top: 10px; display: none;"></div>
                </div>
                
                <div class="probability-controls">
                    <div class="input-group">
                        <label>灵根状态概率设置（总和必须为100%）：</label>
                    </div>
                    <div class="input-group">
                <label for="probNone">无灵根概率：</label>
                <input type="number" id="probNone" value="33" min="0" max="100">
                <span>%</span>
            </div>
            <div id="decodeError" style="color: red; margin-top: 10px; display: none;"></div>
                    <div class="input-group">
                        <label for="probYang">阳灵根概率：</label>
                        <input type="number" id="probYang" value="33" min="0" max="100">
                        <span>%</span>
                    </div>
                    <div class="input-group">
                        <label for="probYin">阴灵根概率：</label>
                        <input type="number" id="probYin" value="34" min="0" max="100">
                        <span>%</span>
                    </div>
                    <div id="probabilityError" style="color: red; margin-top: 10px; display: none;">
                        错误：概率总和必须为100%
                    </div>
                </div>
                
                <div class="root-display" id="singleRootDisplay">
                    <!-- 灵根显示区域 -->
                </div>
                <div class="button-group">
                    <button id="generateSingleBtn">生成灵根</button>
                    <button id="resetSingleBtn">重置</button>
                    <button id="copyAsJsonBtn">复制为JSON</button>
                </div>
                <div class="analysis-panel" id="singleAnalysis">
                    <!-- 分析结果显示区域 -->
                </div>
            </div>

            <div class="panel">
                <h2>批量概率计算</h2>
                <div class="probability-controls">
                    <div class="input-group">
                        <label for="simulationCount">模拟次数：</label>
                        <input type="number" id="simulationCount" value="10000" min="1" max="1000000">
                    </div>
                    <button id="startSimulationBtn">开始模拟</button>
                </div>
                <div class="summary" id="simulationSummary">
                    <!-- 模拟结果摘要 -->
                </div>
            </div>
        </div>

        <div class="probability-section">
            <h2>概率分布结果</h2>
            <div class="results-table-container">
                <table class="results-table" id="probabilityTable">
                    <thead>
                    <tr>
                        <th>灵根组合</th>
                        <th>出现次数</th>
                        <th>概率</th>
                        <th>灵根类型</th>
                        <th>特殊属性</th>
                        <th>详细状态</th>
                    </tr>
                </thead>
                    <tbody>
                        <!-- 概率结果将在这里显示 -->
                    </tbody>
                </table>
            </div>
            <div class="export-section">
                <button id="exportResultsBtn">导出结果</button>
            </div>
        </div>
    </div>

    <script>
        // 定义生克关系
        const relationships = {
            generate: {
                '金': '水',
                '水': '木',
                '木': '火',
                '火': '土',
                '土': '金'
            },
            overcome: {
                '金': '木',
                '木': '土',
                '土': '水',
                '水': '火',
                '火': '金'
            }
        };
        
        // 定义异化灵根映射
        const mutationMap = {
            '金生水': {
                '强化变异': '雷灵根',
                '弱化变异': '冰灵根'
            },
            '水生木': {
                '强化变异': '草灵根',
                '弱化变异': '毒灵根'
            },
            '木生火': {
                '强化变异': '光灵根',
                '弱化变异': '风灵根'
            },
            '火生土': {
                '强化变异': '炎灵根',
                '弱化变异': '暗灵根'
            },
            '土生金': {
                '强化变异': '磁灵根',
                '弱化变异': '岩灵根'
            }
        };

        // 验证概率设置是否有效
        function validateProbabilities() {
            const probNone = parseInt(document.getElementById('probNone').value) || 0;
            const probYang = parseInt(document.getElementById('probYang').value) || 0;
            const probYin = parseInt(document.getElementById('probYin').value) || 0;
            
            const total = probNone + probYang + probYin;
            const errorElement = document.getElementById('probabilityError');
            
            if (total !== 100) {
                errorElement.style.display = 'block';
                return false;
            }
            
            errorElement.style.display = 'none';
            return true;
        }
        
        // 根据概率随机选择状态
        function selectStateByProbability() {
            const probNone = parseInt(document.getElementById('probNone').value) || 0;
            const probYang = parseInt(document.getElementById('probYang').value) || 0;
            const probYin = parseInt(document.getElementById('probYin').value) || 0;
            
            const random = Math.random() * 100;
            
            if (random < probNone) {
                return '无';
            } else if (random < probNone + probYang) {
                return '阳';
            } else {
                return '阴';
            }
        }
        
        // 生成初始灵根状态
        function generateInitialRoots() {
            const elements = ['金', '木', '水', '火', '土'];
            const roots = {};
            
            elements.forEach(element => {
                // 根据概率选择状态
                roots[element] = selectStateByProbability();
            });
            
            return roots;
        }

        // 将初始灵根状态转换为数据化字符串（阳=2，阴=1，无=0）
        function convertRootsToDataString(roots) {
            const order = ['金', '木', '水', '火', '土'];
            const stateMap = {
                '阳': '2',
                '阴': '1',
                '无': '0'
            };
            return order.map(element => stateMap[roots[element]]).join('');
        }
        
        // 将数据化字符串解码为灵根状态（2=阳，1=阴，0=无）
        function decodeDataString(dataString) {
            if (!dataString || typeof dataString !== 'string' || dataString.length !== 5) {
                throw new Error('请输入有效的5位数字字符串（由0、1、2组成）');
            }
            
            const order = ['金', '木', '水', '火', '土'];
            const stateMap = {
                '2': '阳',
                '1': '阴',
                '0': '无'
            };
            
            const roots = {};
            
            for (let i = 0; i < 5; i++) {
                const digit = dataString[i];
                if (!stateMap.hasOwnProperty(digit)) {
                    throw new Error(`输入的第${i+1}位（${digit}）无效，只能是0、1或2`);
                }
                roots[order[i]] = stateMap[digit];
            }
            
            return roots;
        }

        // 根据灵根类型获取基础点数和自由点数
        function getBasePointsByType(rootType) {
            switch(rootType) {
                case '废灵根': return 5;
                case '杂灵根': return 6;
                case '普通灵根': return 7;
                case '地灵根': return 8;
                case '天灵根': return 9;
                case '道体': return 10; // 道体作为特殊类型处理
                default: return 7; // 默认普通灵根
            }
        }
        
        // 计算属性值的函数已定义，此处删除重复定义
        
        // 根据灵根类型获取基础点数和自由点数
        function getBasePointsByType(rootType) {
            switch(rootType) {
                case '废灵根': return 5;
                case '杂灵根': return 6;
                case '普通灵根': return 7;
                case '地灵根': return 8;
                case '天灵根': return 9;
                case '道体': return 10; // 道体作为特殊类型处理
                default: return 7; // 默认普通灵根
            }
        }
        
        // 计算属性值
        function calculateAttributes(dataString, rootType, daoBody = null) {
            // 确定最终的灵根类型（道体优先）
            const finalType = daoBody ? '道体' : rootType;
            
            // 获取基础点数和自由点数
            const basePoints = getBasePointsByType(finalType);
            const freePoints = basePoints; // 自由点数与基础点数相同
            
            // 创建属性映射（对应金木水火土的顺序）
            const attributes = {
                '力量': 0, // 金
                '敏捷': 0, // 火
                '体质': 0, // 土
                '智力': 0, // 水
                '精神': 0, // 木
                '灵根资质': basePoints // 灵根资质直接使用基础点数
            };
            
            const attributeOrder = ['力量', '敏捷', '体质', '智力', '精神'];
            
            // 根据数字串分配基础点数并添加随机浮动
            for (let i = 0; i < 5; i++) {
                const value = parseInt(dataString[i]);
                let baseValue = basePoints;
                
                // 废灵根额外-1
                if (finalType === '废灵根') {
                    baseValue -= 1;
                }
                
                // 根据灵根状态分配点数
                if (value === 2) { // 阳
                    attributes[attributeOrder[i]] = baseValue + Math.floor(Math.random() * 3 - 1); // -1 到 1 的随机数
                } else if (value === 1) { // 阴
                    attributes[attributeOrder[i]] = baseValue + Math.floor(Math.random() * 3 - 1); // -1 到 1 的随机数
                } else { // 无
                    attributes[attributeOrder[i]] = baseValue - 2 + Math.floor(Math.random() * 3 - 1); // 基础点数-2再随机
                }
            }
            
            // 分配自由点数（每个属性随机分配1点，剩余的平均分配）
            let remainingPoints = freePoints;
            
            // 先给每个属性分配1点
            Object.keys(attributes).forEach(attr => {
                attributes[attr] += 1;
                remainingPoints -= 1;
            });
            
            // 剩余点数随机分配
            while (remainingPoints > 0) {
                const attrKeys = Object.keys(attributes);
                const randomAttr = attrKeys[Math.floor(Math.random() * attrKeys.length)];
                attributes[randomAttr] += 1;
                remainingPoints -= 1;
            }
            
            // 确保没有负数属性
            Object.keys(attributes).forEach(attr => {
                attributes[attr] = Math.max(1, attributes[attr]);
            });
            
            console.log('计算出的属性值:', attributes);
            
            return attributes;
        }
        
        // 计算元素抗性
        function calculateResistances(initialRoots, finalRoots, variations) {
            // 创建元素抗性对象（对应金木水火土）
            const resistances = {
                '金': 0,
                '木': 0,
                '水': 0,
                '火': 0,
                '土': 0
            };
            
            // 规则1: 所有阴属性都可以增加元素抗性15
            Object.entries(initialRoots).forEach(([element, state]) => {
                if (state === '阴') {
                    resistances[element] += 15;
                    console.log(`${element}阴属性增加抗性15`);
                }
            });
            
            // 规则2: 废灵根的废属性元素抗性大幅降低
            Object.entries(finalRoots).forEach(([element, state]) => {
                if (state === '废') {
                    // 增加废灵根的减益效果，从-15改为-30，让废属性的负面影响更加明显
                    resistances[element] -= 30;
                    console.log(`${element}废灵根减少抗性30`);
                }
            });
            
            // 规则3: 成功变异的灵根增加促成变异的两种元素各15%
            if (variations && variations.length > 0) {
                variations.forEach(variation => {
                    // 尝试从变异文本中提取两个元素
                    // 变异文本格式类似："金阴生火阳：强化变异" 或 "木阳生水阴：弱化变异"
                    const elementMatch = variation.match(/([金木水火土])(阴|阳|无)?生([金木水火土])(阴|阳|无)?/);
                    if (elementMatch && elementMatch.length >= 5) {
                        const element1 = elementMatch[1];
                        const element2 = elementMatch[3];
                        
                        // 为两个元素增加15%的抗性
                        // 先保存基础抗性值，然后计算百分比加成
                        const baseResistance1 = resistances[element1];
                        const resistanceBonus1 = Math.round(baseResistance1 * 0.5);
                        resistances[element1] += resistanceBonus1;
                        console.log(`${element1}变异加成：+${resistanceBonus1} (15%)`);
                        
                        const baseResistance2 = resistances[element2];
                        const resistanceBonus2 = Math.round(baseResistance2 * 0.5);
                        resistances[element2] += resistanceBonus2;
                        console.log(`${element2}变异加成：+${resistanceBonus2} (15%)`);
                    }
                });
            }
            
            // 允许抗性值低于0
            // 移除了确保抗性不为负的限制
            
            console.log('计算出的元素抗性:', resistances);
            
            return resistances;
        }
        
        // 计算元素加成
        function calculateElementBonus(initialRoots, finalRoots, variations) {
            // 创建元素加成对象（对应金木水火土）
            const elementBonus = {
                '金': 0,
                '木': 0,
                '水': 0,
                '火': 0,
                '土': 0
            };
            
            // 规则1: 所有阳属性都可以增加元素加成15
            Object.entries(initialRoots).forEach(([element, state]) => {
                if (state === '阳') {
                    elementBonus[element] += 15;
                    console.log(`${element}阳属性增加元素加成15`);
                }
            });
            
            // 规则2: 废灵根的废属性元素加成大幅降低
            Object.entries(finalRoots).forEach(([element, state]) => {
                if (state === '废') {
                    elementBonus[element] -= 30;
                    console.log(`${element}废灵根减少元素加成30`);
                }
            });
            
            // 规则3: 成功变异的灵根增加促成变异的两种元素各15%
            if (variations && variations.length > 0) {
                variations.forEach(variation => {
                    // 尝试从变异文本中提取两个元素
                    const elementMatch = variation.match(/([金木水火土])(阴|阳|无)?生([金木水火土])(阴|阳|无)?/);
                    if (elementMatch && elementMatch.length >= 5) {
                        const element1 = elementMatch[1];
                        const element2 = elementMatch[3];
                        
                        // 为两个元素增加15%的加成
                        const baseBonus1 = elementBonus[element1];
                        const bonus1 = Math.round(baseBonus1 * 0.5);
                        elementBonus[element1] += bonus1;
                        console.log(`${element1}变异加成：+${bonus1} (15%)`);
                        
                        const baseBonus2 = elementBonus[element2];
                        const bonus2 = Math.round(baseBonus2 * 0.5);
                        elementBonus[element2] += bonus2;
                        console.log(`${element2}变异加成：+${bonus2} (15%)`);
                    }
                });
            }
            
            console.log('计算出的元素加成:', elementBonus);
            
            return elementBonus;
        }
        
        // 处理生克关系，生成最终灵根状态
        function processRelationships(roots) {
            // 生成数据化字符串
            const dataString = convertRootsToDataString(roots);
            
            const processedRoots = { ...roots };
            const variations = [];
            const weaknesses = [];
            const elementsToDisable = []; // 存储需要变为废的灵根
            const mutationInfo = []; // 存储变异信息，用于异化灵根判断
            
            // 首先使用原始状态计算所有相生关系（变异）
            Object.keys(relationships.generate).forEach(element => {
                const targetElement = relationships.generate[element];
                const elementState = roots[element]; // 使用原始状态
                const targetState = roots[targetElement]; // 使用原始状态
                
                // 检查是否为一阴一阳
                if ((elementState === '阴' && targetState === '阳') || 
                    (elementState === '阳' && targetState === '阴')) {
                    
                    const variationType = elementState === '阴' && targetState === '阳' ? '强化变异' : '弱化变异';
                    const variationText = `${element}${elementState}生${targetElement}${targetState}：${variationType}`;
                    variations.push(variationText);
                    
                    // 存储变异信息，用于异化灵根判断
                    mutationInfo.push({
                        element,
                        targetElement,
                        variationType,
                        relationship: `${element}生${targetElement}`
                    });
                }
            });
            
            // 收集所有需要变为废的灵根
            Object.keys(relationships.overcome).forEach(element => {
                const targetElement = relationships.overcome[element];
                const elementState = roots[element]; // 使用原始状态
                const targetState = roots[targetElement]; // 使用原始状态
                
                // 检查是否同质（双阴或双阳，但不包括双无）
                if ((elementState === '阴' && targetState === '阴') || 
                    (elementState === '阳' && targetState === '阳')) {
                    
                    elementsToDisable.push({
                        element,
                        targetElement,
                        elementState,
                        targetState
                    });
                }
            });
            
            // 一次性将所有需要变为废的灵根设置为废
            elementsToDisable.forEach(item => {
                processedRoots[item.targetElement] = '废';
                weaknesses.push(`${item.element}${item.elementState}克${item.targetElement}${item.targetState}：${item.targetElement}变为废`);
            });
            
            // 处理异化灵根（1/10的几率）
            const mutatedRoots = [];
            if (mutationInfo.length > 0) {
                mutationInfo.forEach(info => {
                    if (Math.random() < 0.1) { // 1/10的几率
                        const alienRoot = mutationMap[info.relationship][info.variationType];
                        mutatedRoots.push(`异化灵根：${alienRoot}（由${info.element}${info.variationType}产生）`);
                    }
                });
            }
            
            // 判断道体（1/100的几率）
            let daoBody = null;
            const hasAllYang = Object.values(roots).every(state => state === '阳');
            const hasAllYin = Object.values(roots).every(state => state === '阴');
            const hasAllNone = Object.values(roots).every(state => state === '无');
            
            if ((hasAllYang || hasAllYin || hasAllNone) && Math.random() < 0.01) { // 1/100的几率
                if (hasAllYang) daoBody = '太初道体';
                else if (hasAllYin) daoBody = '混沌道体';
                else if (hasAllNone) daoBody = '阴阳道体';
            }
            
            return {
                roots: processedRoots,
                variations,
                weaknesses,
                mutatedRoots,
                daoBody,
                initialRoots: roots, // 保存原始灵根状态
                dataString: dataString // 添加数据化字符串
            };
        }
        
        // 判断灵根种类
        function determineRootType(finalRoots, variations, initialRoots) {
            // 检查是否有废灵根
            const hasDisabledRoots = Object.values(finalRoots).includes('废');
            
            // 检查是否没有阳灵根
            const hasNoYangRoots = Object.values(initialRoots).every(state => state !== '阳');
            
            // 计算有效灵根数量（非废、非无）
            const activeRoots = Object.entries(finalRoots).filter(([_, state]) => state !== '废' && state !== '无').length;
            
            // 检查是否有强化变异和弱化变异
            const hasStrongMutation = variations.some(v => v.includes('强化变异'));
            const hasWeakMutation = variations.some(v => v.includes('弱化变异'));
            
            // 根据规则判断灵根类型
            if (hasDisabledRoots || hasNoYangRoots) {
                // 出现废的都是废灵根，五行没有出现阳灵根的也是废灵根
                return '废灵根';
            }
            
            switch (activeRoots) {
                case 1:
                    // 单灵根阳是天灵根
                    return '天灵根';
                    
                case 2:
                    // 双灵根强化变异是天灵根，无变异是地灵根、弱化变异是普通灵根
                    if (hasStrongMutation) return '天灵根';
                    if (hasWeakMutation) return '普通灵根';
                    return '地灵根';
                    
                case 3:
                    // 三灵根强化变异的是地灵根，无变异是普通灵根，弱化变异的是杂灵根
                    if (hasStrongMutation) return '地灵根';
                    if (hasWeakMutation) return '杂灵根';
                    return '普通灵根';
                    
                case 4:
                    // 四灵根强化变异是普通灵根，没有变异的杂灵根，没有强化变异有弱化变异的是废灵根
                    if (hasStrongMutation) return '普通灵根';
                    if (hasWeakMutation && !hasStrongMutation) return '废灵根';
                    return '杂灵根';
                    
                default:
                    // 五灵根默认
                    return '普通灵根';
            }
        }

        // 生成完整的灵根
        function generateSpiritualRoots() {
            const initialRoots = generateInitialRoots();
            const result = processRelationships(initialRoots);
            
            // 判断灵根种类
            const rootType = determineRootType(result.roots, result.variations, initialRoots);
            
            // 计算属性值
            const attributes = calculateAttributes(result.dataString, rootType, result.daoBody);
            
            // 计算元素抗性
            const resistances = calculateResistances(initialRoots, result.roots, result.variations);
            
            // 计算元素加成
            const elementBonus = calculateElementBonus(initialRoots, result.roots, result.variations);
            
            const finalResult = {
                initialRoots,
                finalRoots: result.roots,
                variations: result.variations,
                weaknesses: result.weaknesses,
                rootType,
                mutatedRoots: result.mutatedRoots,
                daoBody: result.daoBody,
                dataString: result.dataString, // 包含数据化字符串
                attributes: attributes, // 包含计算出的属性
                resistances: resistances, // 包含计算出的元素抗性
                elementBonus: elementBonus // 包含计算出的元素加成
            };
            
            console.log('generateSpiritualRoots返回的结果:', finalResult);
            
            return finalResult;
        }

        // 显示灵根
        function displayRoots(roots, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            Object.entries(roots).forEach(([element, state]) => {
                const rootItem = document.createElement('div');
                rootItem.className = 'root-item';
                
                const rootName = document.createElement('div');
                rootName.className = 'root-name';
                rootName.textContent = element;
                
                const rootState = document.createElement('div');
                rootState.className = `root-state ${state}`;
                rootState.textContent = state;
                
                rootItem.appendChild(rootName);
                rootItem.appendChild(rootState);
                container.appendChild(rootItem);
            });
        }

        // 显示分析结果
        function displayAnalysis(variations, weaknesses, rootType, mutatedRoots, daoBody, containerId, dataString = '', attributes = null, resistances = null, elementBonus = null) {
            console.log('displayAnalysis接收到的属性:', attributes);
            
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            // 显示数据化字符串
            const dataStringItem = document.createElement('div');
            dataStringItem.className = 'analysis-item';
            dataStringItem.style.backgroundColor = '#e3f2fd';
            dataStringItem.style.fontWeight = 'bold';
            dataStringItem.style.textAlign = 'center';
            dataStringItem.style.marginBottom = '15px';
            dataStringItem.textContent = `数据化字符串：${dataString}`;
            container.appendChild(dataStringItem);
            
            // 显示灵根种类（使用特殊样式突出显示）
            const rootTypeItem = document.createElement('div');
            rootTypeItem.className = 'analysis-item';
            rootTypeItem.style.backgroundColor = '#fff3cd';
            rootTypeItem.style.fontWeight = 'bold';
            rootTypeItem.style.textAlign = 'center';
            rootTypeItem.style.marginBottom = '15px';
            rootTypeItem.style.padding = '15px';
            rootTypeItem.style.borderRadius = '8px';
            rootTypeItem.textContent = `灵根种类：${rootType}`;
            container.appendChild(rootTypeItem);
            
            // 显示属性值（如果提供）
            if (attributes) {
                console.log('开始显示属性，属性对象有属性数量:', Object.keys(attributes).length);
                
                const attributesContainer = document.createElement('div');
                attributesContainer.className = 'analysis-item';
                attributesContainer.style.backgroundColor = '#f8f9fa';
                attributesContainer.style.padding = '15px';
                attributesContainer.style.marginBottom = '15px';
                attributesContainer.style.borderRadius = '8px';
                attributesContainer.style.fontWeight = 'bold';
                attributesContainer.style.border = '2px solid red'; // 添加边框以便更容易看到
                
                const attributesTitle = document.createElement('div');
                attributesTitle.textContent = '基础属性：';
                attributesTitle.style.marginBottom = '10px';
                attributesContainer.appendChild(attributesTitle);
                
                const attributesList = document.createElement('div');
                attributesList.style.display = 'grid';
                attributesList.style.gridTemplateColumns = '1fr 1fr';
                attributesList.style.gap = '8px';
                
                Object.entries(attributes).forEach(([attr, value]) => {
                    console.log(`添加属性项: ${attr} = ${value}`);
                    const attrItem = document.createElement('div');
                    attrItem.style.display = 'flex';
                    attrItem.style.justifyContent = 'space-between';
                    attrItem.textContent = `${attr}：${value}`;
                    attrItem.style.fontSize = '16px'; // 增大字体以便更容易看到
                    attributesList.appendChild(attrItem);
                });
                
                attributesContainer.appendChild(attributesList);
                container.appendChild(attributesContainer);
                
                console.log('属性容器已添加到DOM');
            } else {
                console.log('attributes为null或undefined');
            }
            
            // 显示元素抗性（如果提供）
            if (resistances) {
                console.log('开始显示元素抗性，抗性对象:', resistances);
                
                const resistancesContainer = document.createElement('div');
                resistancesContainer.className = 'analysis-item';
                resistancesContainer.style.backgroundColor = '#e8f5e9';
                resistancesContainer.style.padding = '15px';
                resistancesContainer.style.marginBottom = '15px';
                resistancesContainer.style.borderRadius = '8px';
                resistancesContainer.style.fontWeight = 'bold';
                resistancesContainer.style.border = '2px solid green'; // 添加绿色边框以便更容易看到
                
                const resistancesTitle = document.createElement('div');
                resistancesTitle.textContent = '元素抗性：';
                resistancesTitle.style.marginBottom = '10px';
                resistancesContainer.appendChild(resistancesTitle);
                
                const resistancesList = document.createElement('div');
                resistancesList.style.display = 'grid';
                resistancesList.style.gridTemplateColumns = '1fr 1fr';
                resistancesList.style.gap = '8px';
                
                // 定义元素抗性的顺序
                const resistanceOrder = ['金', '木', '水', '火', '土'];
                
                // 为每个元素抗性创建显示项
                resistanceOrder.forEach(element => {
                    const resistanceItem = document.createElement('div');
                    resistanceItem.style.display = 'flex';
                    resistanceItem.style.justifyContent = 'space-between';
                    resistanceItem.style.padding = '5px';
                    resistanceItem.style.backgroundColor = '#f1f8e9';
                    resistanceItem.style.borderRadius = '4px';
                    
                    resistanceItem.innerHTML = `<span>${element}元素抗性：</span><span style="font-weight: bold;">${resistances[element] || 0}</span>`;
                    resistancesList.appendChild(resistanceItem);
                });
                
                resistancesContainer.appendChild(resistancesList);
                
                // 添加到容器
                container.appendChild(resistancesContainer);
                console.log('抗性容器已添加到DOM:', resistancesContainer.isConnected);
            }
            
            // 显示元素加成（如果提供）
            if (elementBonus) {
                console.log('开始显示元素加成，加成对象:', elementBonus);
                
                const bonusContainer = document.createElement('div');
                bonusContainer.className = 'analysis-item';
                bonusContainer.style.backgroundColor = '#fff3e0';
                bonusContainer.style.padding = '15px';
                bonusContainer.style.marginBottom = '15px';
                bonusContainer.style.borderRadius = '8px';
                bonusContainer.style.fontWeight = 'bold';
                bonusContainer.style.border = '2px solid orange'; // 添加橙色边框以便更容易看到
                
                const bonusTitle = document.createElement('div');
                bonusTitle.textContent = '元素加成：';
                bonusTitle.style.marginBottom = '10px';
                bonusContainer.appendChild(bonusTitle);
                
                const bonusList = document.createElement('div');
                bonusList.style.display = 'grid';
                bonusList.style.gridTemplateColumns = '1fr 1fr';
                bonusList.style.gap = '8px';
                
                // 定义元素加成的顺序
                const bonusOrder = ['金', '木', '水', '火', '土'];
                
                // 为每个元素加成创建显示项
                bonusOrder.forEach(element => {
                    const bonusItem = document.createElement('div');
                    bonusItem.style.display = 'flex';
                    bonusItem.style.justifyContent = 'space-between';
                    bonusItem.style.padding = '5px';
                    bonusItem.style.backgroundColor = '#fff8e1';
                    bonusItem.style.borderRadius = '4px';
                    
                    bonusItem.innerHTML = `<span>${element}元素加成：</span><span style="font-weight: bold;">${elementBonus[element] || 0}</span>`;
                    bonusList.appendChild(bonusItem);
                });
                
                bonusContainer.appendChild(bonusList);
                
                // 添加到容器
                container.appendChild(bonusContainer);
                console.log('加成容器已添加到DOM:', bonusContainer.isConnected);
            }
            
            // 显示道体（如果有）
            if (daoBody) {
                const daoBodyItem = document.createElement('div');
                daoBodyItem.className = 'analysis-item';
                daoBodyItem.style.backgroundColor = '#d4edda';
                daoBodyItem.style.color = '#155724';
                daoBodyItem.style.fontWeight = 'bold';
                daoBodyItem.style.textAlign = 'center';
                daoBodyItem.textContent = `特殊体质：${daoBody}`;
                container.appendChild(daoBodyItem);
            }
            
            // 显示异化灵根
            if (mutatedRoots && mutatedRoots.length > 0) {
                mutatedRoots.forEach(mutated => {
                    const item = document.createElement('div');
                    item.className = 'analysis-item variation';
                    item.style.backgroundColor = '#e8f5e9';
                    item.textContent = mutated;
                    container.appendChild(item);
                });
            }
            
            // 添加变异分析
            if (variations.length > 0) {
                variations.forEach(variation => {
                    const item = document.createElement('div');
                    item.className = 'analysis-item variation';
                    item.textContent = variation;
                    container.appendChild(item);
                });
            }
            
            // 添加弱点分析
            if (weaknesses.length > 0) {
                weaknesses.forEach(weakness => {
                    const item = document.createElement('div');
                    item.className = 'analysis-item weakness';
                    item.textContent = weakness;
                    container.appendChild(item);
                });
            }
            
            // 如果没有变异和弱点
            if (variations.length === 0 && weaknesses.length === 0 && (!mutatedRoots || mutatedRoots.length === 0)) {
                const item = document.createElement('div');
                item.className = 'analysis-item';
                item.textContent = '没有发生变异或废灵根';
                container.appendChild(item);
            }
        }

        // 为概率输入框添加验证
        document.getElementById('probNone').addEventListener('input', validateProbabilities);
        document.getElementById('probYang').addEventListener('input', validateProbabilities);
        document.getElementById('probYin').addEventListener('input', validateProbabilities);
        
        // 初始化时验证概率
        validateProbabilities();
        
        // 单次生成按钮点击事件
        document.getElementById('generateSingleBtn').addEventListener('click', () => {
            // 首先验证概率设置
            if (!validateProbabilities()) {
                alert('请确保概率总和为100%');
                return;
            }
            
            const result = generateSpiritualRoots();
            displayRoots(result.finalRoots, 'singleRootDisplay');
            displayAnalysis(
                result.variations, 
                result.weaknesses, 
                result.rootType, 
                result.mutatedRoots, 
                result.daoBody, 
                'singleAnalysis',
                result.dataString,
                result.attributes,
                result.resistances,
                result.elementBonus
            );
        });

        // 重置按钮点击事件
        document.getElementById('resetSingleBtn').addEventListener('click', () => {
            document.getElementById('singleRootDisplay').innerHTML = '';
            document.getElementById('singleAnalysis').innerHTML = '';
            document.getElementById('dataStringInput').value = '';
            document.getElementById('decodeError').style.display = 'none';
        });
        
        // 解码按钮点击事件
        document.getElementById('decodeBtn').addEventListener('click', () => {
            const input = document.getElementById('dataStringInput').value.trim();
            const errorElement = document.getElementById('decodeError');
            
            try {
                // 隐藏之前的错误信息
                errorElement.style.display = 'none';
                
                // 验证输入是否全为数字
                if (!/^[012]{5}$/.test(input)) {
                    throw new Error('请输入有效的5位数字字符串，只能包含0、1、2');
                }
                
                // 解码数据字符串
                const initialRoots = decodeDataString(input);
                
                // 使用解码后的灵根进行处理
                const processResult = processRelationships(initialRoots);
                const rootType = determineRootType(processResult.roots, processResult.variations, initialRoots);
                
                // 计算属性值
                const attributes = calculateAttributes(input, rootType, processResult.daoBody);
                
                // 计算元素抗性
                const resistances = calculateResistances(initialRoots, processResult.roots, processResult.variations);
                
                // 计算元素加成
                const elementBonus = calculateElementBonus(initialRoots, processResult.roots, processResult.variations);
                
                // 构建完整结果对象
                const result = {
                    initialRoots,
                    finalRoots: processResult.roots,
                    variations: processResult.variations,
                    weaknesses: processResult.weaknesses,
                    rootType,
                    mutatedRoots: processResult.mutatedRoots,
                    daoBody: processResult.daoBody,
                    dataString: input,
                    attributes: attributes,
                    resistances: resistances,
                    elementBonus: elementBonus
                };
                
                // 显示结果
                displayRoots(result.finalRoots, 'singleRootDisplay');
                displayAnalysis(
                    result.variations, 
                    result.weaknesses, 
                    result.rootType, 
                    result.mutatedRoots, 
                    result.daoBody, 
                    'singleAnalysis',
                    result.dataString,
                    result.attributes,
                    result.resistances,
                    result.elementBonus
                );
                
            } catch (error) {
                errorElement.textContent = error.message;
                errorElement.style.display = 'block';
            }
        });
        
        // 为数据字符串输入框添加键盘事件（按Enter解码）
        document.getElementById('dataStringInput').addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                document.getElementById('decodeBtn').click();
            }
        });
        
        // 限制数据字符串输入框只能输入0、1、2
        document.getElementById('dataStringInput').addEventListener('input', (event) => {
            event.target.value = event.target.value.replace(/[^012]/g, '');
        });

        // 批量模拟函数
        function simulateMultiple(count) {
            const results = {};
            const typeCounts = {}; // 统计各种灵根类型的出现次数
            const totalCombinations = Math.pow(3, 5); // 每个灵根有3种初始状态，共5个灵根
            
            console.log(`开始模拟 ${count} 次...`);
            
            for (let i = 0; i < count; i++) {
                const result = generateSpiritualRoots();
                const rootKey = JSON.stringify(result.finalRoots);
                
                if (!results[rootKey]) {
                    results[rootKey] = {
                    count: 0,
                    roots: result.finalRoots,
                    initialRoots: result.initialRoots,
                    rootType: result.rootType,
                    dataString: result.dataString, // 添加数据化字符串
                    attributes: result.attributes, // 添加属性信息
                    // 只有非废灵根的异化灵根才标记为hasMutatedRoots
                    hasMutatedRoots: result.mutatedRoots && result.mutatedRoots.length > 0 && result.rootType !== '废灵根',
                    hasDaoBody: !!result.daoBody
                };
                }
                
                results[rootKey].count++;
                
                // 统计灵根类型
                typeCounts[result.rootType] = (typeCounts[result.rootType] || 0) + 1;
                
                // 统计特殊情况 - 只有非废灵根的异化灵根才计入统计
                if (result.mutatedRoots && result.mutatedRoots.length > 0 && result.rootType !== '废灵根') {
                    typeCounts['异化灵根'] = (typeCounts['异化灵根'] || 0) + 1;
                }
                if (result.daoBody) {
                    typeCounts[result.daoBody] = (typeCounts[result.daoBody] || 0) + 1;
                }
            }
            
            return {
                rootResults: results,
                typeCounts
            };
        }

        // 格式化灵根状态显示
        function formatRootsDisplay(roots) {
            return Object.entries(roots)
                .map(([element, state]) => `${element}${state}`)
                .join('');
        }

        // 显示概率结果
        function displayProbabilityResults(results, totalCount) {
            const tableBody = document.getElementById('probabilityTable').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = '';
            
            // 转换为数组并按出现次数排序
            const sortedResults = Object.entries(results.rootResults)
                .map(([key, data]) => ({
                    ...data,
                    probability: (data.count / totalCount * 100).toFixed(4)
                }))
                .sort((a, b) => b.count - a.count);
            
            // 更新表格
            sortedResults.forEach(item => {
                const row = tableBody.insertRow();
                
                const combinationCell = row.insertCell(0);
                combinationCell.textContent = formatRootsDisplay(item.roots);
                combinationCell.title = `数据化字符串: ${item.dataString}`;
                
                const countCell = row.insertCell(1);
                countCell.textContent = item.count;
                
                const probabilityCell = row.insertCell(2);
                probabilityCell.textContent = `${item.probability}%`;
                
                const typeCell = row.insertCell(3);
                typeCell.textContent = item.rootType;
                
                const specialCell = row.insertCell(4);
                const specials = [];
                if (item.hasMutatedRoots) specials.push('异化灵根');
                if (item.hasDaoBody) specials.push('道体');
                specialCell.textContent = specials.join(', ') || '-';
                
                const detailsCell = row.insertCell(5);
                detailsCell.textContent = JSON.stringify(item.roots);
            });
            
            // 生成灵根类型统计HTML
            let typeStatsHtml = '<h4>灵根类型统计：</h4><ul>';
            Object.entries(results.typeCounts)
                .sort(([,a], [,b]) => b - a)
                .forEach(([type, count]) => {
                    const probability = (count / totalCount * 100).toFixed(4);
                    typeStatsHtml += `<li>${type}: ${count}次 (${probability}%)</li>`;
                });
            typeStatsHtml += '</ul>';
            
            // 更新摘要
            const summary = document.getElementById('simulationSummary');
            summary.innerHTML = `
                <p>模拟次数：${totalCount}</p>
                <p>出现的不同组合数：${sortedResults.length}</p>
                <p>理论可能的组合数：${Math.pow(4, 5)} (每个灵根有4种可能状态)</p>
                ${typeStatsHtml}
            `;
        }

        // 开始模拟按钮点击事件
        document.getElementById('startSimulationBtn').addEventListener('click', () => {
            const count = parseInt(document.getElementById('simulationCount').value);
            if (isNaN(count) || count < 1) {
                alert('请输入有效的模拟次数');
                return;
            }
            
            // 显示加载状态
            const summary = document.getElementById('simulationSummary');
            summary.innerHTML = '<p>模拟进行中，请稍候...</p>';
            
            // 使用setTimeout允许UI更新
            setTimeout(() => {
                const results = simulateMultiple(count);
                displayProbabilityResults(results, count);
            }, 100);
        });

        // 导出结果
        document.getElementById('exportResultsBtn').addEventListener('click', () => {
            const table = document.getElementById('probabilityTable');
            let csvContent = '灵根组合,出现次数,概率,灵根类型,特殊属性,详细状态\n';
            
            // 收集表格数据
            const rows = table.getElementsByTagName('tr');
            for (let i = 1; i < rows.length; i++) { // 跳过表头
                const cells = rows[i].getElementsByTagName('td');
                if (cells.length > 0) {
                    const values = Array.from(cells).map(cell => 
                        `"${cell.textContent.replace(/"/g, '""')}"`
                    );
                    csvContent += values.join(',') + '\n';
                }
            }
            
            // 创建下载链接
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `灵根概率结果_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // 存储当前生成的灵根数据
        let currentRootData = null;

        // 更新生成灵根和解码灵根的函数，存储当前数据
        const originalGenerateSingleBtnClick = document.getElementById('generateSingleBtn').onclick;
        document.getElementById('generateSingleBtn').onclick = function() {
            // 先执行原有的点击事件
            if (originalGenerateSingleBtnClick) {
                originalGenerateSingleBtnClick.apply(this, arguments);
            }
        };

        const originalDecodeBtnClick = document.getElementById('decodeBtn').onclick;
        document.getElementById('decodeBtn').onclick = function() {
            // 先执行原有的点击事件
            if (originalDecodeBtnClick) {
                originalDecodeBtnClick.apply(this, arguments);
            }
        };

        // 重写processRelationships函数，存储处理后的数据
        const originalProcessRelationships = processRelationships;
        processRelationships = function(roots) {
            const result = originalProcessRelationships(roots);
            // 计算并存储当前的属性、抗性和加成数据
            const rootType = determineRootType(result.roots, result.variations, result.initialRoots);
            const attributes = calculateAttributes(result.dataString, rootType, result.daoBody);
            const resistances = calculateResistances(result.initialRoots, result.roots, result.variations);
            const elementBonus = calculateElementBonus(result.initialRoots, result.roots, result.variations);
            
            currentRootData = {
                roots: result.roots,
                initialRoots: result.initialRoots,
                rootType: rootType,
                daoBody: result.daoBody,
                variations: result.variations,
                attributes: attributes,
                resistances: resistances,
                elementBonus: elementBonus,
                dataString: result.dataString
            };
            
            return result;
        };

        // 复制为JSON按钮点击事件
        document.getElementById('copyAsJsonBtn').addEventListener('click', () => {
            if (!currentRootData) {
                alert('请先生成灵根后再复制JSON数据');
                return;
            }
            
            // 准备要复制的数据，只包含需要的字段
            const jsonData = {
                基础属性: currentRootData.attributes,
                元素抗性: currentRootData.resistances,
                元素加成: currentRootData.elementBonus
            };
            
            // 转换为格式化的JSON字符串
            const jsonString = JSON.stringify(jsonData, null, 2);
            
            // 复制到剪贴板
            navigator.clipboard.writeText(jsonString).then(() => {
                alert('JSON数据已成功复制到剪贴板');
            }).catch(err => {
                console.error('复制失败:', err);
                alert('复制失败，请手动复制');
            });
        });
    </script>
</body>
</html>